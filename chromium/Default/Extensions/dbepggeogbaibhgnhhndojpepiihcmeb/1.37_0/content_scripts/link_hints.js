// Generated by CoffeeScript 1.3.3
(function() {
  var LinkHints, alphabetHints, filterHints, hintUtils, root;

  LinkHints = {
    hintMarkers: [],
    hintMarkerContainingDiv: null,
    shouldOpenInNewTab: false,
    shouldOpenWithQueue: false,
    linkActivator: void 0,
    delayMode: false,
    markerMatcher: void 0,
    isActive: false,
    init: function() {
      this.onKeyDownInMode = this.onKeyDownInMode.bind(this);
      return this.markerMatcher = settings.get("filterLinkHints") ? filterHints : alphabetHints;
    },
    clickableElementsXPath: DomUtils.makeXPath(["a", "area[@href]", "textarea", "button", "select", "input[not(@type='hidden' or @disabled or @readonly)]", "*[@onclick or @tabindex or @role='link' or @role='button' or contains(@class, 'button') or " + "@contenteditable='' or translate(@contenteditable, 'TRUE', 'true')='true']"]),
    activateModeToOpenInNewTab: function() {
      return this.activateMode(true, false, false);
    },
    activateModeToCopyLinkUrl: function() {
      return this.activateMode(null, false, true);
    },
    activateModeWithQueue: function() {
      return this.activateMode(true, true, false);
    },
    activateMode: function(openInNewTab, withQueue, copyLinkUrl) {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      if (!document.getElementById("vimiumLinkHintCss")) {
        addCssToPage(linkHintCss, "vimiumLinkHintCss");
      }
      this.setOpenLinkMode(openInNewTab, withQueue, copyLinkUrl);
      this.buildLinkHints();
      return handlerStack.push({
        keydown: this.onKeyDownInMode,
        keypress: function() {
          return false;
        },
        keyup: function() {
          return false;
        }
      });
    },
    setOpenLinkMode: function(openInNewTab, withQueue, copyLinkUrl) {
      this.shouldOpenInNewTab = openInNewTab;
      this.shouldOpenWithQueue = withQueue;
      if (openInNewTab || withQueue) {
        if (openInNewTab) {
          HUD.show("Open link in new tab");
        } else if (withQueue) {
          HUD.show("Open multiple links in a new tab");
        }
        return this.linkActivator = function(link) {
          return DomUtils.simulateClick(link, {
            metaKey: KeyboardUtils.platform === "Mac",
            ctrlKey: KeyboardUtils.platform !== "Mac"
          });
        };
      } else if (copyLinkUrl) {
        HUD.show("Copy link URL to Clipboard");
        return this.linkActivator = function(link) {
          return chrome.extension.sendRequest({
            handler: "copyToClipboard",
            data: link.href
          });
        };
      } else {
        HUD.show("Open link in current tab");
        return this.linkActivator = function(link) {
          return setTimeout(DomUtils.simulateClick.bind(DomUtils, link), 400);
        };
      }
    },
    buildLinkHints: function() {
      var marker, visibleElements, _i, _len, _ref;
      visibleElements = this.getVisibleClickableElements();
      this.hintMarkers = this.markerMatcher.getHintMarkers(visibleElements);
      this.hintMarkerContainingDiv = document.createElement("div");
      this.hintMarkerContainingDiv.id = "vimiumHintMarkerContainer";
      this.hintMarkerContainingDiv.className = "vimiumReset";
      _ref = this.hintMarkers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        this.hintMarkerContainingDiv.appendChild(marker);
      }
      if (document.documentElement) {
        return document.documentElement.appendChild(this.hintMarkerContainingDiv);
      } else {
        return this.deactivateMode();
      }
    },
    getVisibleClickableElements: function() {
      var c, clientRect, coords, element, i, img, imgClientRects, map, rect, resultSet, visibleElements, _i, _ref;
      resultSet = DomUtils.evaluateXPath(this.clickableElementsXPath, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
      visibleElements = [];
      for (i = _i = 0, _ref = resultSet.snapshotLength; _i < _ref; i = _i += 1) {
        element = resultSet.snapshotItem(i);
        clientRect = DomUtils.getVisibleClientRect(element, clientRect);
        if (clientRect !== null) {
          visibleElements.push({
            element: element,
            rect: clientRect
          });
        }
        if (element.localName === "area") {
          map = element.parentElement;
          if (!map) {
            continue;
          }
          img = document.querySelector("img[usemap='#" + map.getAttribute("name") + "']");
          if (!img) {
            continue;
          }
          imgClientRects = img.getClientRects();
          if (imgClientRects.length === 0) {
            continue;
          }
          c = element.coords.split(/,/);
          coords = [parseInt(c[0], 10), parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10)];
          rect = {
            top: imgClientRects[0].top + coords[1],
            left: imgClientRects[0].left + coords[0],
            right: imgClientRects[0].left + coords[2],
            bottom: imgClientRects[0].top + coords[3],
            width: coords[2] - coords[0],
            height: coords[3] - coords[1]
          };
          visibleElements.push({
            element: element,
            rect: rect
          });
        }
      }
      return visibleElements;
    },
    onKeyDownInMode: function(event) {
      var delay, i, keyResult, linksMatched, marker, matched, _ref, _ref1;
      if (this.delayMode) {
        return;
      }
      if (event.keyCode === keyCodes.shiftKey && this.shouldOpenInNewTab !== null) {
        this.setOpenLinkMode(!this.shouldOpenInNewTab, this.shouldOpenWithQueue, false);
        handlerStack.push({
          keyup: function(event) {
            if (event.keyCode !== keyCodes.shiftKey) {
              return;
            }
            LinkHints.setOpenLinkMode(!LinkHints.shouldOpenInNewTab, LinkHints.shouldOpenWithQueue, false);
            return handlerStack.pop();
          }
        });
      }
      if (KeyboardUtils.isEscape(event)) {
        this.deactivateMode();
      } else {
        keyResult = this.markerMatcher.matchHintsByKey(event, this.hintMarkers);
        linksMatched = keyResult.linksMatched;
        delay = (_ref = keyResult.delay) != null ? _ref : 0;
        if (linksMatched.length === 0) {
          this.deactivateMode();
        } else if (linksMatched.length === 1) {
          this.activateLink(linksMatched[0], delay);
        } else {
          _ref1 = this.hintMarkers;
          for (i in _ref1) {
            marker = _ref1[i];
            this.hideMarker(marker);
          }
          for (i in linksMatched) {
            matched = linksMatched[i];
            this.showMarker(matched, this.markerMatcher.hintKeystrokeQueue.length);
          }
        }
      }
      return false;
    },
    activateLink: function(matchedLink, delay) {
      var clickEl;
      this.delayMode = true;
      clickEl = matchedLink.clickableItem;
      if (DomUtils.isSelectable(clickEl)) {
        DomUtils.simulateSelect(clickEl);
        return this.deactivateMode(delay, function() {
          return LinkHints.delayMode = false;
        });
      } else {
        if (clickEl.nodeName.toLowerCase() === "input" && clickEl.type !== "button") {
          clickEl.focus();
        }
        DomUtils.flashRect(matchedLink.rect);
        this.linkActivator(clickEl);
        if (this.shouldOpenWithQueue) {
          return this.deactivateMode(delay, function() {
            LinkHints.delayMode = false;
            return LinkHints.activateModeWithQueue();
          });
        } else {
          return this.deactivateMode(delay, function() {
            return LinkHints.delayMode = false;
          });
        }
      }
    },
    showMarker: function(linkMarker, matchingCharCount) {
      var j, _i, _ref, _results;
      linkMarker.style.display = "";
      _results = [];
      for (j = _i = 0, _ref = linkMarker.childNodes.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        if (j < matchingCharCount) {
          _results.push(linkMarker.childNodes[j].classList.add("matchingCharacter"));
        } else {
          _results.push(linkMarker.childNodes[j].classList.remove("matchingCharacter"));
        }
      }
      return _results;
    },
    hideMarker: function(linkMarker) {
      return linkMarker.style.display = "none";
    },
    deactivateMode: function(delay, callback) {
      var deactivate,
        _this = this;
      deactivate = function() {
        if (LinkHints.markerMatcher.deactivate) {
          LinkHints.markerMatcher.deactivate();
        }
        if (LinkHints.hintMarkerContainingDiv) {
          LinkHints.hintMarkerContainingDiv.parentNode.removeChild(LinkHints.hintMarkerContainingDiv);
        }
        LinkHints.hintMarkerContainingDiv = null;
        LinkHints.hintMarkers = [];
        handlerStack.pop();
        HUD.hide();
        return _this.isActive = false;
      };
      if (!delay) {
        deactivate();
        if (callback) {
          return callback();
        }
      } else {
        return setTimeout(function() {
          deactivate();
          if (callback) {
            return callback();
          }
        }, delay);
      }
    }
  };

  alphabetHints = {
    hintKeystrokeQueue: [],
    logXOfBase: function(x, base) {
      return Math.log(x) / Math.log(base);
    },
    getHintMarkers: function(visibleElements) {
      var hintMarkers, hintStrings, i, marker, _i, _ref;
      hintStrings = this.hintStrings(visibleElements.length);
      hintMarkers = [];
      for (i = _i = 0, _ref = visibleElements.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        marker = hintUtils.createMarkerFor(visibleElements[i]);
        marker.hintString = hintStrings[i];
        marker.innerHTML = hintUtils.spanWrap(marker.hintString.toUpperCase());
        hintMarkers.push(marker);
      }
      return hintMarkers;
    },
    hintStrings: function(linkCount) {
      var digitsNeeded, hintStrings, i, linkHintCharacters, longHintCount, shortHintCount, start, _i, _j, _ref;
      linkHintCharacters = settings.get("linkHintCharacters");
      digitsNeeded = Math.ceil(this.logXOfBase(linkCount, linkHintCharacters.length));
      shortHintCount = Math.floor((Math.pow(linkHintCharacters.length, digitsNeeded) - linkCount) / linkHintCharacters.length);
      longHintCount = linkCount - shortHintCount;
      hintStrings = [];
      if (digitsNeeded > 1) {
        for (i = _i = 0; 0 <= shortHintCount ? _i < shortHintCount : _i > shortHintCount; i = 0 <= shortHintCount ? ++_i : --_i) {
          hintStrings.push(this.numberToHintString(i, digitsNeeded - 1, linkHintCharacters));
        }
      }
      start = shortHintCount * linkHintCharacters.length;
      for (i = _j = start, _ref = start + longHintCount; start <= _ref ? _j < _ref : _j > _ref; i = start <= _ref ? ++_j : --_j) {
        hintStrings.push(this.numberToHintString(i, digitsNeeded, linkHintCharacters));
      }
      return this.shuffleHints(hintStrings, linkHintCharacters.length);
    },
    shuffleHints: function(hints, characterSetLength) {
      var bucket, buckets, hint, i, result, _i, _j, _len, _len1;
      buckets = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < characterSetLength; i = _i += 1) {
          _results.push([]);
        }
        return _results;
      })();
      for (_i = 0, _len = hints.length; _i < _len; _i++) {
        hint = hints[_i];
        buckets[i % buckets.length].push(hint);
      }
      result = [];
      for (_j = 0, _len1 = buckets.length; _j < _len1; _j++) {
        bucket = buckets[_j];
        result = result.concat(bucket);
      }
      return result;
    },
    numberToHintString: function(number, numHintDigits, characterSet) {
      var base, hintString, hintStringLength, i, remainder, _i, _ref;
      base = characterSet.length;
      hintString = [];
      remainder = 0;
      while (true) {
        remainder = number % base;
        hintString.unshift(characterSet[remainder]);
        number -= remainder;
        number /= Math.floor(base);
        if (!(number > 0)) {
          break;
        }
      }
      hintStringLength = hintString.length;
      for (i = _i = 0, _ref = numHintDigits - hintStringLength; _i < _ref; i = _i += 1) {
        hintString.unshift(characterSet[0]);
      }
      return hintString.join("");
    },
    matchHintsByKey: function(event, hintMarkers) {
      var keyChar, linksMatched, matchString;
      keyChar = KeyboardUtils.getKeyChar(event).toLowerCase();
      if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        if (!this.hintKeystrokeQueue.pop()) {
          return {
            linksMatched: []
          };
        }
      } else if (keyChar && settings.get("linkHintCharacters").indexOf(keyChar) >= 0) {
        this.hintKeystrokeQueue.push(keyChar);
      }
      matchString = this.hintKeystrokeQueue.join("");
      linksMatched = hintMarkers.filter(function(linkMarker) {
        return linkMarker.hintString.indexOf(matchString) === 0;
      });
      return {
        linksMatched: linksMatched
      };
    },
    deactivate: function() {
      return this.hintKeystrokeQueue = [];
    }
  };

  filterHints = {
    hintKeystrokeQueue: [],
    linkTextKeystrokeQueue: [],
    labelMap: {},
    generateLabelMap: function() {
      var forElement, label, labelText, labels, _i, _len, _results;
      labels = document.querySelectorAll("label");
      _results = [];
      for (_i = 0, _len = labels.length; _i < _len; _i++) {
        label = labels[_i];
        forElement = label.getAttribute("for");
        if (forElement) {
          labelText = label.textContent.trim();
          if (labelText[labelText.length - 1] === ":") {
            labelText = labelText.substr(0, labelText.length - 1);
          }
          _results.push(this.labelMap[forElement] = labelText);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    generateHintString: function(linkHintNumber) {
      return (linkHintNumber + 1).toString();
    },
    generateLinkText: function(element) {
      var linkText, nodeName, showLinkText;
      linkText = "";
      showLinkText = false;
      nodeName = element.nodeName.toLowerCase();
      if (nodeName === "input") {
        if (this.labelMap[element.id]) {
          linkText = this.labelMap[element.id];
          showLinkText = true;
        } else if (element.type !== "password") {
          linkText = element.value;
        }
      } else if (nodeName === "a" && !element.textContent.trim() && element.firstElementChild && element.firstElementChild.nodeName.toLowerCase() === "img") {
        linkText = element.firstElementChild.alt || element.firstElementChild.title;
        if (linkText) {
          showLinkText = true;
        }
      } else {
        linkText = element.textContent || element.innerHTML;
      }
      return {
        text: linkText,
        show: showLinkText
      };
    },
    renderMarker: function(marker) {
      return marker.innerHTML = hintUtils.spanWrap(marker.hintString + (marker.showLinkText ? ": " + marker.linkText : ""));
    },
    getHintMarkers: function(visibleElements) {
      var hintMarkers, i, linkTextObject, marker, visibleElement, _i, _len;
      this.generateLabelMap();
      hintMarkers = [];
      for (i = _i = 0, _len = visibleElements.length; _i < _len; i = ++_i) {
        visibleElement = visibleElements[i];
        marker = hintUtils.createMarkerFor(visibleElement);
        marker.hintString = this.generateHintString(i);
        linkTextObject = this.generateLinkText(marker.clickableItem);
        marker.linkText = linkTextObject.text;
        marker.showLinkText = linkTextObject.show;
        this.renderMarker(marker);
        hintMarkers.push(marker);
      }
      return hintMarkers;
    },
    matchHintsByKey: function(event, hintMarkers) {
      var delay, keyChar, linksMatched, marker, matchString, userIsTypingLinkText, _i, _len;
      keyChar = KeyboardUtils.getKeyChar(event);
      delay = 0;
      userIsTypingLinkText = false;
      if (event.keyCode === keyCodes.enter) {
        for (_i = 0, _len = hintMarkers.length; _i < _len; _i++) {
          marker = hintMarkers[_i];
          if (marker.style.display !== "none") {
            return {
              linksMatched: [marker]
            };
          }
        }
      } else if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        if (!this.hintKeystrokeQueue.pop() && !this.linkTextKeystrokeQueue.pop()) {
          return {
            linksMatched: []
          };
        }
      } else if (keyChar) {
        if (/[0-9]/.test(keyChar)) {
          this.hintKeystrokeQueue.push(keyChar);
        } else {
          this.hintKeystrokeQueue = [];
          this.linkTextKeystrokeQueue.push(keyChar);
          userIsTypingLinkText = true;
        }
      }
      linksMatched = this.filterLinkHints(hintMarkers);
      matchString = this.hintKeystrokeQueue.join("");
      linksMatched = linksMatched.filter(function(linkMarker) {
        return !linkMarker.filtered && linkMarker.hintString.indexOf(matchString) === 0;
      });
      if (linksMatched.length === 1 && userIsTypingLinkText) {
        delay = 200;
      }
      return {
        linksMatched: linksMatched,
        delay: delay
      };
    },
    filterLinkHints: function(hintMarkers) {
      var linkMarker, linkSearchString, linksMatched, matchedLink, oldHintString, _i, _len;
      linksMatched = [];
      linkSearchString = this.linkTextKeystrokeQueue.join("");
      for (_i = 0, _len = hintMarkers.length; _i < _len; _i++) {
        linkMarker = hintMarkers[_i];
        matchedLink = linkMarker.linkText.toLowerCase().indexOf(linkSearchString.toLowerCase()) >= 0;
        if (!matchedLink) {
          linkMarker.filtered = true;
        } else {
          linkMarker.filtered = false;
          oldHintString = linkMarker.hintString;
          linkMarker.hintString = this.generateHintString(linksMatched.length);
          if (linkMarker.hintString !== oldHintString) {
            this.renderMarker(linkMarker);
          }
          linksMatched.push(linkMarker);
        }
      }
      return linksMatched;
    },
    deactivate: function(delay, callback) {
      this.hintKeystrokeQueue = [];
      this.linkTextKeystrokeQueue = [];
      return this.labelMap = {};
    }
  };

  hintUtils = {
    spanWrap: function(hintString) {
      var char, innerHTML, _i, _len;
      innerHTML = [];
      for (_i = 0, _len = hintString.length; _i < _len; _i++) {
        char = hintString[_i];
        innerHTML.push("<span class='vimiumReset'>" + char + "</span>");
      }
      return innerHTML.join("");
    },
    createMarkerFor: function(link) {
      var clientRect, marker;
      marker = document.createElement("div");
      marker.className = "vimiumReset internalVimiumHintMarker vimiumHintMarker";
      marker.clickableItem = link.element;
      clientRect = link.rect;
      marker.style.left = clientRect.left + window.scrollX + "px";
      marker.style.top = clientRect.top + window.scrollY + "px";
      marker.rect = link.rect;
      return marker;
    }
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.LinkHints = LinkHints;

}).call(this);
